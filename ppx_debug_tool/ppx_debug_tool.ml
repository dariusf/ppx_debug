open Containers

(* we're not in ppxlib, because we're accessing the typedtree, which likely is out of scope.
   we probably aren't protected against breakage as well. *)
open Ocaml_common
module A = Ppxlib.Ast_builder.Default

let p_t expr =
  Format.printf "%a@." Pprintast.expression (Untypeast.untype_expression expr)

type id = string * string * int

(* this is generated code, so it comes from ppxlib *)
type typ_info = {
  (* if none, it's a type we can't unmarshal *)
  typ : Ppxlib.core_type option;
  show_fn : Ppxlib.expression;
}

let id_type_mappings : (id * typ_info) list ref = ref []
let p_te t = Format.printf "type %a@." Printtyp.type_expr t

let handle_expr modname it expr =
  let loc = expr.Typedtree.exp_loc in
  match expr.Typedtree.exp_desc with
  | Texp_apply
      ( {
          exp_desc =
            Texp_ident
              ( _,
                {
                  txt = Ldot (Ldot (Lident "Ppx_debug_runtime", "Trace"), name);
                  _;
                },
                _ );
          _;
        },
        args )
    when String.equal name "emit_value" || String.equal name "emit_argument" ->
    let site_id =
      args
      |> List.filter_map (function
           | Asttypes.Labelled "ppx_debug_id", Some tuple ->
             begin
               match tuple.Typedtree.exp_desc with
               | Texp_tuple
                   [
                     (* we can't use __FILE__ and __FUNCTION__ as these have not been expanded at ppx-processing time *)
                     { exp_desc = Texp_constant (Const_string (file, _, _)); _ };
                     (* { exp_desc = Texp_constant (Const_string (func, _, _)); _; }; *)
                     _;
                     { exp_desc = Texp_constant (Const_int id); _ };
                   ] ->
                 Some (file, "func", id)
               | _ ->
                 (* this shouldn't happen as we're only expecting a triple here (generated by ppx_debug), but it's possible the pattern in the last branch is wrong/too strict *)
                 p_t tuple;
                 failwith "expecting a triple as argument to ppx_debug_id"
             end
           | _ -> None)
      |> List.head_opt
      |> Option.get_exn_or "no ppx_debug_id argument"
    in
    let exp_type =
      let e =
        args |> List.last_opt
        |> Option.get_exn_or "no arguments?"
        |> snd
        |> Option.get_exn_or "last argument had no value"
      in
      e.exp_type
    in
    let qual =
      match modname with
      | [] -> failwith "modname cannot be empty"
      | m :: ms -> List.fold_left Ppxlib.(fun t c -> Ldot (t, c)) (Lident m) ms
    in
    let typ_name =
      match Types.get_desc exp_type with
      | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "unit"
        ->
        Some (Ppxlib.Lident "unit")
      (* Ldot (qual, typ_name) *)
      | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "int"
        ->
        Some (Lident "int")
      | Tconstr (Pident ident, _, _) -> Some (Ldot (qual, Ident.name ident))
      | Tvar _ ->
        (* "<poly>" *)
        None
      (* "Lib." ^ Ident.name ident *)
      (* "x" *)
      (* | T (Pident ident, _, _) -> *)
      | _ ->
        p_te exp_type;
        failwith "nyi"
    in
    let show_fn =
      match Types.get_desc exp_type with
      | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "int"
        ->
        (* [%expr string_of_int] *)
        A.pexp_ident ~loc { loc; txt = Lident "string_of_int" }
      | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "unit"
        ->
        [%expr fun () -> "()"]
      | Tconstr (Pident ident, _, _) ->
        A.pexp_ident ~loc { loc; txt = Ldot (qual, "show_" ^ Ident.name ident) }
        (* Ident.name ident *)
      | Tvar _ -> [%expr fun _ -> "<poly>"]
      (* "Lib." ^ Ident.name ident *)
      (* "x" *)
      (* | T (Pident ident, _, _) -> *)
      | _ ->
        p_te exp_type;
        failwith "nyi"
    in
    let typ =
      (* typ_name |> Option.map (fun typ_name -> ) *)
      let open Option.Infix in
      let+ typ_name in
      Ppxlib.
        {
          ptyp_desc = Ptyp_constr ({ loc; txt = typ_name }, []);
          ptyp_loc = loc;
          ptyp_loc_stack = [];
          ptyp_attributes = [];
        }
    in
    (* begin
       match typ with
       | Some typ -> *)
    id_type_mappings := (site_id, { show_fn; typ }) :: !id_type_mappings
    (* | None -> ()
       end *)
    (* args
       |> List.iter (fun (label, a) ->
              match a with
              | Some a ->
                Format.printf "  arg %a %a@." Pprintast.expression
                  (Untypeast.untype_expression a)
                  Location.print_loc a.exp_loc
              | None -> Format.printf "  arg absent?@.");
       () *)
  | _ ->
    (* it.Tast_iterator.expr it expr *)
    Tast_iterator.default_iterator.expr it expr
(* Format.printf "typed expr %a@." Pprintast.expression
   (Untypeast.untype_expression expr) *)

let walk_build_dir () =
  (* let _ = *)
  (* print_endline ("walking " ^ Sys.getcwd ()); *)
  (* we're inside _build/default *)
  let should_ignore s =
    (* TODO heuristic. config? *)
    not (String.mem ~sub:"test/" s)
  in
  IO.File.walk_seq "."
  |> Seq.iter (function
       | `File, s when String.ends_with ~suffix:"cmt" s && should_ignore s ->
         (* print_endline s; *)
         let cmt = Cmt_format.read_cmt s in
         let modname = cmt.cmt_modname |> String.split ~by:"." in
         (* let () =
              match cmt.cmt_sourcefile with
              | None -> print_endline "no source file"
              | Some s -> Format.printf "file %s@." s
            in *)
         let str =
           match cmt.cmt_annots with
           | Implementation str -> str
           | _ -> failwith "not a cmt file"
         in
         (* Format.printf "typed ast %a@." Printtyped.implementation str; *)
         (* print_endline "traversing cmt"; *)
         let iter_structure =
           Tast_iterator.(
             default_iterator.structure
               {
                 default_iterator with
                 (* value_binding = handle_vb; *)
                 expr = handle_expr modname;
               })
         in
         iter_structure str
       | _ -> ())
(* in *)
(* print_endline "ok" *)

open Ppxlib

let handle_si ~loc ~path:_ _payload =
  (* TODO use payload for name of identifier *)
  (* TODO go up until git, since this will reside in dune build dir *)
  (* let config = Util.read_config () in
     if config.debug then
       (traverse ())#structure_item str
     else
       str *)
  (* str *)
  (* [ *)
  walk_build_dir ();
  let cases =
    A.pexp_match ~loc [%expr id]
      ((!id_type_mappings
       |> List.map (fun ((file, _func, id), typ_info) ->
              (* let typ_ident = A.pexp_ident ~loc { loc; txt = Lident typ } in *)
              (* let typ_ident = A.pexp_ident ~loc { loc; txt = Lident typ } in *)
              let show_arg =
                match typ_info.typ with
                | None -> [%expr ()]
                | Some typ ->
                  [%expr (Marshal.from_string _content 0 : [%t typ])]
              in
              A.case
                ~lhs:
                  (A.ppat_tuple ~loc
                     [
                       A.pstring ~loc file;
                       A.ppat_any ~loc;
                       (* A.ppat_any ~loc; *)
                       (* A.pstring ~loc func; *)
                       A.pint ~loc id;
                     ])
                ~guard:None
                ~rhs:
                  [%expr
                    let _content = Scanf.bscanf _file "%s@\n" Fun.id in
                    [%e typ_info.show_fn] [%e show_arg]]))
      @ [
          A.case
            ~lhs:(A.ppat_tuple ~loc [[%pat? file]; A.ppat_any ~loc; [%pat? id]])
            ~guard:None
            ~rhs:[%expr failwith (Format.sprintf "unknown type %s %d" file id)];
        ])
  in
  (* unsure why we have to prefix file with an underscore, or the compiler thinks it's unused *)
  let read = [%expr fun _file id -> [%e cases]] in
  (* !id_type_mappings |> List.map (); *)
  [%stri let read_and_print_value = [%e read]]
(* failwith "" *)

(* Scanf.bscanf file "%s@\n%s@\n" (fun id content ->
    Format.printf "%s %s@." id
      (show_b (Marshal.from_string content 0 : b))) *)

let rule =
  Ppxlib.Context_free.Rule.extension
    (Extension.declare "generate" Structure_item
       (* Ast_pattern.(pstr (__ ^:: nil)) *)
       (* Ast_pattern.(pstr __) *)
       Ast_pattern.(__)
       handle_si)

let () =
  Driver.register_transformation ~rules:[rule (* ; rule_expr *)]
    "ppx_debug_tool"
