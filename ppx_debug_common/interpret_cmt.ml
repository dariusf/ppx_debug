open Containers
module Config = Ppx_debug_runtime.Config

module L = Log.Make (struct
  let name = (Config.read ()).internal_tool_log
end)

let log = L.log

(* we're not in ppxlib, because we're accessing the typedtree, which likely is out of scope.
   we probably aren't protected against breakage as well. *)
open Ocaml_common
module A = Ppxlib.Ast_builder.Default
module C = Ppx_debug_runtime.Config

let p_t expr =
  Format.printf "%a@." Pprintast.expression (Untypeast.untype_expression expr)

module Id = Ppx_debug_runtime.Trace.Id

(* this is generated code, so it comes from ppxlib *)
type typ_info = {
  (* if none, it's a type we can't unmarshal *)
  typ : Ppxlib.core_type option;
  pp_fn : Ppxlib.expression;
}

let id_type_mappings : (Id.t * typ_info) list ref = ref []
let p_te t = Format.printf "type %a@." Printtyp.type_expr t

(* this could return 'a always and it should still be fine as long as the printer generated by show_fn matches the id numbers of emit statements *)
let create_typ_name ~loc _qual exp_type =
  (* let open Option.Infix in
     let+ typ_name in
     Ppxlib.
       {
         ptyp_desc = Ptyp_constr ({ loc; txt = typ_name }, []);
         ptyp_loc = loc;
         ptyp_loc_stack = [];
         ptyp_attributes = [];
       } *)
  match Types.get_desc exp_type with
  | Tconstr (Pident ident, [], _) when String.equal (Ident.name ident) "unit" ->
    (* Some (Ppxlib.Lident "unit") *)
    Some (A.ptyp_constr ~loc { txt = Ppxlib.Lident "unit"; loc } [])
  (* Ldot (qual, typ_name) *)
  | Tconstr (Pident ident, [], _) when String.equal (Ident.name ident) "int" ->
    (* Some (Lident "int") *)
    Some (A.ptyp_constr ~loc { txt = Ppxlib.Lident "int"; loc } [])
  | Tconstr (Pident _ident, _params, _) ->
    (* TODO params? *)
    (* Some (Ldot (qual, Ident.name ident)) *)
    (* failwith "nyi" *)
    None
    (* Some (A.ptyp_var ~loc "a") *)
    (* Some
       (A.ptyp_constr ~loc
          { txt = Ldot (qual, Ident.name ident); loc }
          List.map create_typ_name params) *)
  | Tvar _ ->
    (* can't unmarshal polymorphic types *)
    None
  (* "Lib." ^ Ident.name ident *)
  (* "x" *)
  (* | T (Pident ident, _, _) -> *)
  | _ -> None
(* Some (A.ptyp_var ~loc "nyi") *)

(* let contains s1 s2 =
    let re = Str.regexp_string s2
    in
        try ignore (Str.search_forward re s1 0); true
        with Not_found -> false *)

open Result.Infix

let with_ctx m res =
  match res with Error s -> Error (Format.asprintf "%s: %s" m s) | Ok _ -> res

module LR = List.Traverse (struct
  type 'a t = ('a, string) result

  let return = Result.return
  let ( >>= ) = Result.( >>= )
end)

(* let map_m f e = match e with
     | Error s -> Result.return (Error s)
     | Ok x -> f x >>= fun y -> Result.return (Ok y)

   let sequence_m m = map_m (fun x->x) m *)

(* begin
     match q with
     | Pident i
       when String.equal (Ident.name i) "Stdlib"
            && List.mem ~eq:String.equal ident ["in_channel"] ->
       [%expr fun fmt _ -> Format.fprintf fmt "<opaque>"]
     | _ ->
       let f =
         A.pexp_ident ~loc
           {
             loc;
             txt =
               Ldot
                 ( path_to_lident q,
                   match ident with "t" -> "pp" | _ -> "pp_" ^ ident );
           }
       in
       (match args with
       | [] -> f
       | _ :: _ ->
         let p_args =
           List.map (create_pp_fn ~loc qual) args
           |> List.map (fun a -> (Ppxlib.Nolabel, a))
         in
         A.pexp_apply ~loc f p_args)
   end *)
(* | Tconstr (Pident ident, args, _) ->
   log "unqualified ident %s, qual = %a" (Ident.name ident) Pprintast.longident
     qual;
   let f =
     A.pexp_ident ~loc
       {
         loc;
         txt =
           Ldot
             (* assume that the type is defined where it is used *)
             ( qual,
               match Ident.name ident with
               | "t" -> "pp"
               | _ -> "pp_" ^ Ident.name ident );
       }
   in
   (match args with
   | [] -> f
   | _ :: _ ->
     let p_args =
       List.map (create_pp_fn ~loc qual) args
       |> List.map (fun a -> (Ppxlib.Nolabel, a))
     in
     A.pexp_apply ~loc f p_args) *)

let relativize ~against path =
  let regexp = Str.regexp (Format.asprintf {|^\(%s\)/?\(.*\)|} against) in
  Str.string_match regexp path 0 |> ignore;
  try Some (Str.matched_group 2 path) with Invalid_argument _ -> None

let file_to_module =
  let dot_ml = Str.regexp {|\.ml|} in
  let slash = Str.regexp {|/|} in
  fun path ->
    let res =
      List.map String.capitalize_ascii
        (path |> Str.global_replace dot_ml "" |> Str.split slash)
    in
    match List.rev res with
    | a :: b :: c when String.equal a b -> List.rev (b :: c)
    | _ -> res

let%expect_test _ =
  let show a = a |> [%derive.show: string option] |> print_endline in
  relativize ~against:"demo/lib" "demo/lib/lib.ml" |> show;
  relativize ~against:"a" "demo/lib/lib.ml" |> show;
  relativize ~against:"demo/lib/" "demo/lib/lib.ml" |> show;
  let show a = a |> [%derive.show: string list] |> print_endline in
  file_to_module "demo/lib/other.ml" |> show;
  file_to_module "demo/lib/lib.ml" |> show;
  file_to_module "lib.ml" |> show;
  [%expect
    {|
  (Some "lib.ml")
  None
  (Some "lib.ml")
  ["Demo"; "Lib"; "Other"]
  ["Demo"; "Lib"]
  ["Lib"]
  |}]

let rec path_to_lident p =
  match p with
  | Path.Pdot (p, s) -> Longident.Ldot (path_to_lident p, s)
  | Pident i -> Lident (Ident.name i)
  | Papply _ -> failwith "no correspondence"

let flatten_path p =
  match Path.flatten p with
  | `Ok (h, xs) -> Ident.name h :: xs
  | `Contains_apply -> failwith "adklj"

let path_to_s p = flatten_path p |> String.concat "."
let demangle modname = List.concat_map (String.split ~by:"__") modname

let mnl_to_lident modname =
  match modname with
  | [] -> failwith "modname cannot be empty"
  | m :: ms -> List.fold_left Ppxlib.(fun t c -> Ldot (t, c)) (Lident m) ms

(* pp because show is non-compositional.
   file and qual are for the current compilation unit, i.e. where exp_type is used.
*)
let rec printer_and_type =
  let variant = (C.read ()).variant in
  fun ~loc env file modname exp_type ->
    (* undo the mangling dune does to get a path we can refer to values with *)
    let normal_type ?(args = []) name =
      A.ptyp_constr ~loc { txt = Ppxlib.Lident name; loc } args
    in
    let handle_result a b =
      (* can't use this as it specializes the second arg to string *)
      (* (match containers with
         | true ->
           [%expr Result.pp [%e generate_printer_typ a] [%e generate_printer_typ b]]
         | _ -> *)
      let pp_a, ta = printer_and_type ~loc env file modname a in
      let pp_b, tb = printer_and_type ~loc env file modname b in
      ( Ppxlib.([%expr Format.pp_print_result ~ok:[%e pp_a] ~error:[%e pp_b]]),
        let* ta =
          with_ctx
            (Format.asprintf "type for %a failed" Ppxlib.Pprintast.expression
               pp_a)
            ta
        in
        let+ tb =
          with_ctx
            (Format.asprintf "type for %a failed" Ppxlib.Pprintast.expression
               pp_b)
            tb
        in
        normal_type ~args:[ta; tb] "result" )
      (* ) *)
    in
    match Types.get_desc exp_type with
    | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "int" ->
      ( Ppxlib.(
          match variant with
          | Containers -> [%expr CCInt.pp]
          | Stdlib -> [%expr Format.pp_print_int]),
        Ok (normal_type "int") )
    | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "char"
      ->
      ( Ppxlib.(
          match variant with
          | Containers -> [%expr CCChar.pp]
          | Stdlib -> [%expr Format.pp_print_char]),
        Ok (normal_type "char") )
    | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "float"
      ->
      ( (match variant with
        | Containers -> [%expr CCFloat.pp]
        | Stdlib -> [%expr Format.pp_print_float]),
        Ok (normal_type "float") )
    | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "bool"
      ->
      ( (match variant with
        | Containers -> [%expr CCString.pp]
        | Stdlib -> [%expr Format.pp_print_bool]),
        Ok (normal_type "bool") )
    | Tconstr (Pident ident, _, _) when String.equal (Ident.name ident) "string"
      ->
      ( (match variant with
        | Containers -> [%expr CCString.pp]
        | Stdlib -> [%expr Format.pp_print_string]),
        Ok (normal_type "string") )
    | Tconstr (Pident ident, [a], _)
      when String.equal (Ident.name ident) "option" ->
      let pp_a, ta = printer_and_type ~loc env file modname a in
      ( (match variant with
        | Containers -> [%expr CCOpt.pp [%e pp_a]]
        | Stdlib -> [%expr Format.pp_print_option [%e pp_a]]),
        let+ ta in
        normal_type ~args:[ta] "option" )
    | Tconstr (Pident ident, [a; b], _)
      when String.equal (Ident.name ident) "result" ->
      handle_result a b
    | Tconstr (Pdot (Pident q, "result"), [a; b], _)
      when String.equal (Ident.name q) "Stdlib" ->
      handle_result a b
    | Tconstr (Pident ident, [a], _) when String.equal (Ident.name ident) "list"
      ->
      let pp_a, ta = printer_and_type ~loc env file modname a in
      ( (match variant with
        | Containers ->
          [%expr
            CCList.pp
              ~pp_start:(fun fmt () -> Format.fprintf fmt "[")
              ~pp_stop:(fun fmt () -> Format.fprintf fmt "]")
              ~pp_sep:(fun fmt () -> Format.fprintf fmt ";")
              [%e pp_a]]
        | Stdlib ->
          [%expr
            fun fmt xs ->
              Format.fprintf fmt "[";
              Format.pp_print_list
                ~pp_sep:(fun fmt () -> Format.fprintf fmt ";@ ")
                [%e pp_a] fmt xs;
              Format.fprintf fmt "]"]),
        let+ ta in
        normal_type ~args:[ta] "list" )
    | Tconstr (Pident ident, [], _) when String.equal (Ident.name ident) "unit"
      ->
      ([%expr fun fmt () -> Format.fprintf fmt "()"], Ok (normal_type "unit"))
      (* the following two cases are the same except for the qualifiers *)
    | Tconstr (id, args, _) -> guess_named_type loc env file modname id args
    | Tvar v ->
      ( [%expr fun fmt _ -> Format.fprintf fmt "<poly>"],
        (* Error "type variable" *)
        Ok (A.ptyp_var ~loc (v |> Option.get_or ~default:"a"))
        (* A.ptyp_constr ~loc { txt = Ppxlib.Lident name; loc } args *) )
    | Tarrow _ ->
      ([%expr fun fmt _ -> Format.fprintf fmt "<fn>"], Error "function")
    | Ttuple _ ->
      (* TODO *)
      ([%expr fun fmt _ -> Format.fprintf fmt "<tuple>"], Error "tuple")
    (* "Lib." ^ Ident.name ident *)
    (* "x" *)
    (* | T (Pident ident, _, _) -> *)
    | _ ->
      (* p_te exp_type; *)
      (* failwith "nyi" *)
      ( [%expr fun fmt _ -> Format.fprintf fmt "<unimplemented>"],
        Error "unimplemented" )

and guess_named_type =
  let library_entrypoints = (C.read ()).libraries in
  fun loc env use_file use_modname id args ->
    (* log "qualified ident %a" Path.print id; *)
    (* Pdot (q, ident) *)
    (* qual is where the use of the type is found, q is where the type is defined *)
    (* TOOD existing uses of qual are probably wrong *)
    let mappings =
      (* List.assoc_opt ~eq:String.equal file (C.read ()).mappings
      *)
      C.SMap.find_opt use_file (C.read ()).mappings
      |> Option.get_or ~default:C.SMap.empty
    in
    let opaque_regexes = (C.read ()).treat_as_opaque |> List.map Str.regexp in
    match id with
    (* Path.Pdot (Pident _i, _ident) *)
    | _
      when (* List.mem ~eq:String.equal (path_to_s id) (C.read ()).treat_as_opaque *)
           (* List.mem ~eq:String.equal (path_to_s id)
              (C.read ()).treat_as_opaque *)
           List.exists
             (fun r -> Str.string_match r (path_to_s id) 0)
             opaque_regexes
           ||
           match
             (* List.assoc_opt ~eq:String.equal (path_to_s id) mappings *)
             C.SMap.find_opt (path_to_s id) mappings
           with
           | Some Opaque -> true
           | _ -> false
           (* when String.equal (Ident.name i) "Stdlib" *)
           (* && List.mem ~eq:String.equal ident ["in_channel"] *) ->
      log "opaque %s %b %b" (path_to_s id)
        (List.exists
           (fun r -> Str.string_match r (path_to_s id) 0)
           opaque_regexes)
        (match
           (* List.assoc_opt ~eq:String.equal (path_to_s id) mappings *)
           C.SMap.find_opt (path_to_s id) mappings
         with
        | Some Opaque -> true
        | _ -> false);
      ([%expr fun fmt _ -> Format.fprintf fmt "<opaque>"], Error "opaque type")
    | _ ->
      (* we have to figure out where some type is defined from where it is used in order to point to the right printer. *)
      let get_pp_name typ = match typ with "t" -> "pp" | _ -> "pp_" ^ typ in
      let qualifier, ident_name =
        let typdecl = Env.find_type id env in
        (* Format.printf "%a@." Location.print_loc *)
        let decl_filename = typdecl.type_loc.loc_start.pos_fname in
        let first_matching f xs =
          List.fold_left
            (fun t c -> match t with None -> f c | Some _ -> t)
            None xs
        in

        (* let entrypoint =
             List.find_opt (fun le ->) library_entrypoints
           in *)
        (* how to refer to this type via the entrypoint of the lib it is in *)

        (* let def_mod_prefix, def_mod =
             match
               first_matching
                 (fun le ->
                   match relativize ~against:le decl_filename with
                   | None -> None
                   | Some def_file ->
                     Format.printf "matched %a. le: %s, file: %s@." Path.print id
                       le def_file;
                     let prefix = file_to_module (Filename.basename le) in
                     let def_mod = file_to_module def_file in
                     if String.equal use_file def_file then (
                       print_endline "equal file, no prefixes at all";
                       Some ([], []))
                     else (
                       match relativize ~against:le use_file with
                       | None ->
                         Format.printf "failed, so using full name@.";
                         Some (prefix, def_mod)
                       | Some _ ->
                         Format.printf "succeeded, so dropping prefix@.";
                         Some ([], def_mod))
                   (* Some
                      ( file_to_module (Filename.basename le),
                        (* List.concat_map file_to_module (String.split ~by:"." file) *)
                        file_to_module file ) *))
                 library_entrypoints
             with
             | None ->
               let s = String.split ~by:"." use_file in
               ([List.hd s], List.tl s)
             | Some (p, m) -> (p, m)
           in *)
        let def_prefix =
          match
            first_matching
              (fun le ->
                match relativize ~against:le decl_filename with
                | None -> None
                | Some def_file ->
                  (* Format.printf "matched. le: %s@." le;
                     Format.printf "def_file: %s@." def_file;
                     Format.printf "decl_filename: %s@." decl_filename; *)
                  let e = file_to_module (Filename.basename le) in
                  let m = file_to_module def_file in
                  if List.equal String.equal e m then Some e else Some (e @ m))
              library_entrypoints
          with
          | None ->
            (* let s = String.split ~by:"." use_file in
               ([List.hd s], List.tl s) *)
            file_to_module use_file
          | Some p -> p
        in

        (* Format.printf "def_mod_prefix: %a@."
             (Format.pp_print_list Format.pp_print_string)
             def_mod_prefix;
           Format.printf "def_mod: %a@."
             (Format.pp_print_list Format.pp_print_string)
             def_mod; *)

        (* Format.printf "def mod %a@."
           (Option.pp
              (Pair.pp (Pair.pp String.pp String.pp) (List.pp String.pp)))
           def_mod; *)
        (* if no library entrypoints are given, assume the first part is the library *)
        (* edge cases. if the compilation unit we're in is the same, drop the prefix *)
        (* drop more prefixes if we're in the same module as the definition *)

        (* let _old () =
             match id with
             | _ when C.SMap.mem (path_to_s id) mappings ->
               log "found mapping for %s" (path_to_s id);
               let zz =
                 match C.SMap.find (path_to_s id) mappings with
                 | Rewrite s -> s
                 | _ -> failwith "invalid"
               in
               let li, ident =
                 let li =
                   Longident.unflatten (String.split_on_char '.' zz)
                   |> Option.get_exn_or "cannot parse longident"
                 in
                 match li with
                 | Longident.Ldot (li, ident) -> (li, ident)
                 | _ -> failwith "asd"
               in
               (li, ident)
             | Path.Pdot (q, ident) ->
               log "another comp unit %s" (path_to_s id);
               let x = Env.find_type id env in
               Format.printf "%d@." x.type_arity;
               Format.printf "%a@." Location.print_loc x.type_loc;
               (path_to_lident q, ident)
             | Pident ident ->
               log "unqualified %s" (path_to_s id);
               (mnl_to_lident use_modname, Ident.name ident)
             | Papply _ -> failwith "not applicable"
           in *)

        (* old *)
        (* let qual = mnl_to_lident (def_mod_prefix @ def_mod) in *)
        let qual = mnl_to_lident def_prefix in
        let new1 =
          match id with
          | Path.Pdot (_, ident) -> (qual, ident)
          | Pident ident -> (qual, Ident.name ident)
          | _ -> failwith "app"
        in
        new1
      in

      (* file: the file we're currently processing *)
      (* qual: the module we're in, e.g. Lib *)
      (* id: how we're referring to the type from the module we're in, e.g. Other.t *)
      (* qualifier, ident_name: outputs *)
      log
        "printer name: (use_file = %s, use_modname = %a, id = %a) -guess-> \
         (qualifier = %a, ident_name = %s)"
        use_file
        (* Pprintast.longident qual *)
        (List.pp String.pp)
        use_modname Path.print id Pprintast.longident qualifier ident_name;
      let printer =
        A.pexp_ident ~loc
          {
            loc;
            txt =
              Ldot
                ( qualifier (* path_to_lident q *),
                  get_pp_name ident_name
                  (* match ident_name with
                     | "t" -> "pp"
                     | _ ->
                       "pp_"
                       ^ (* ident *)
                       ident_name *) );
          }
      in
      let tident args =
        A.ptyp_constr ~loc { loc; txt = Ldot (qualifier, ident_name) } args
      in
      (match args with
      | [] -> (printer, Ok (tident []))
      | _ :: _ ->
        let p_args =
          List.map
            (fun a -> printer_and_type ~loc env use_file use_modname a)
            args
        in
        let p_args, types = List.split p_args in
        let p_args = p_args |> List.map (fun a -> (Ppxlib.Nolabel, a)) in
        let types = LR.sequence_m types in
        ( A.pexp_apply ~loc printer p_args,
          let* types in
          Ok (tident types) ))

let handle_expr use_modname it expr =
  let loc = expr.Typedtree.exp_loc in
  match expr.Typedtree.exp_desc with
  | Texp_apply
      ( {
          exp_desc =
            Texp_ident
              ( _,
                {
                  txt = Ldot (Ldot (Lident "Ppx_debug_runtime", "Trace"), name);
                  _;
                },
                _ );
          _;
        },
        args )
    when String.equal name "emit_value"
         || String.equal name "emit_argument"
         || String.equal name "emit_raw" ->
    let site_id =
      args
      |> List.filter_map (function
           | Asttypes.Labelled "ppx_debug_id", Some tuple ->
             begin
               match tuple.Typedtree.exp_desc with
               (* | Texp_tuple
                   [
                     (* we can't use __FILE__ and __FUNCTION__ as these have not been expanded at ppx-processing time *)
                     { exp_desc = Texp_constant (Const_string (file, _, _)); _ };
                     (* { exp_desc = Texp_constant (Const_string (func, _, _)); _; }; *)
                     _;
                     { exp_desc = Texp_constant (Const_int id); _ };
                   ] -> *)
               | Texp_record
                   {
                     fields =
                       [|
                         ( _,
                           Overridden
                             ( _file,
                               {
                                 exp_desc =
                                   Texp_constant (Const_string (file, _, _));
                                 _;
                               } ) );
                         ( _,
                           Overridden
                             ( _id,
                               { exp_desc = Texp_constant (Const_int id); _ } )
                         );
                         ( _,
                           Overridden
                             ( _loc,
                               {
                                 exp_desc =
                                   Texp_tuple
                                     [
                                       {
                                         exp_desc =
                                           Texp_tuple
                                             [
                                               {
                                                 exp_desc =
                                                   Texp_constant (Const_int sl);
                                                 _;
                                               };
                                               {
                                                 exp_desc =
                                                   Texp_constant (Const_int sc);
                                                 _;
                                               };
                                             ];
                                         _;
                                       };
                                       {
                                         exp_desc =
                                           Texp_tuple
                                             [
                                               {
                                                 exp_desc =
                                                   Texp_constant (Const_int el);
                                                 _;
                                               };
                                               {
                                                 exp_desc =
                                                   Texp_constant (Const_int ec);
                                                 _;
                                               };
                                             ];
                                         _;
                                       };
                                     ];
                                 _;
                               } ) );
                       |];
                     _;
                   } ->
                 Some Id.{ file; id; loc = ((sl, sc), (el, ec)) }
               | _ ->
                 (* this shouldn't happen as we're only expecting a triple here (generated by ppx_debug), but it's possible the pattern in the last branch is wrong/too strict *)
                 p_t tuple;
                 failwith "expecting a triple as argument to ppx_debug_id"
             end
           | _ -> None)
      |> List.head_opt
      |> Option.get_exn_or "no ppx_debug_id argument"
    in
    let exp_type =
      let e =
        args |> List.last_opt
        |> Option.get_exn_or "no arguments?"
        |> snd
        |> Option.get_exn_or "last argument had no value"
      in
      e.exp_type
    in
    let env = expr.exp_env in
    let pp_fn, typ =
      printer_and_type ~loc env site_id.file use_modname exp_type
    in
    (* let typ = create_typ_name ~loc qual exp_type in *)
    (* begin
       match typ with
       | Some typ -> *)
    (* let () = *)
    log "file = %s, id = %d -> exp_type = %a | pp_fn = %a | typ = %a"
      site_id.file site_id.id Printtyp.type_expr exp_type
      Ppxlib.Pprintast.expression pp_fn
      (Result.pp Ppxlib.Pprintast.core_type)
      typ;

    (* | %a *)
    (* (Option.pp Ppxlib.Pprintast.core_type) *)
    (* typ *)
    (* in *)
    let typ = Result.to_opt typ in
    id_type_mappings := (site_id, { pp_fn; typ }) :: !id_type_mappings
    (* | None -> ()
       end *)
    (* args
       |> List.iter (fun (label, a) ->
              match a with
              | Some a ->
                Format.printf "  arg %a %a@." Pprintast.expression
                  (Untypeast.untype_expression a)
                  Location.print_loc a.exp_loc
              | None -> Format.printf "  arg absent?@.");
       () *)
  | _ ->
    (* it.Tast_iterator.expr it expr *)
    Tast_iterator.default_iterator.expr it expr
(* Format.printf "typed expr %a@." Pprintast.expression
   (Untypeast.untype_expression expr) *)

let walk_build_dir () =
  (* let _ = *)
  (* print_endline ("walking " ^ Sys.getcwd ()); *)
  (* we're inside _build/default *)
  let should_ignore s =
    (* TODO heuristic. config? *)
    not (String.mem ~sub:"test/" s)
  in
  IO.File.walk_seq "."
  |> Seq.iter (function
       | `File, s when String.ends_with ~suffix:"cmt" s && should_ignore s ->
         let cmt = Cmt_format.read_cmt s in
         Load_path.init cmt.cmt_loadpath;
         (* TODO does this do anything? *)
         let modname = cmt.cmt_modname |> String.split ~by:"." in
         (* let () =
              match cmt.cmt_sourcefile with
              | None -> print_endline "no source file"
              | Some s -> Format.printf "file %s@." s
            in *)
         let str =
           match cmt.cmt_annots with
           | Implementation str ->
             let map =
               {
                 Tast_mapper.default with
                 env = (fun _ env -> Envaux.env_of_only_summary env);
               }
             in
             let str = map.structure map str in
             str
           | _ -> failwith "not a cmt file"
         in
         (* let _ =
              let env = cmt.cmt_initial_env in
              let x = Env.diff Env.empty env in
              print_endline "idents";
              List.iter (fun x -> Format.printf "i: %a" Ident.print x) x;
              env
            in *)
         (* Format.printf "typed ast %a@." Printtyped.implementation str; *)
         (* print_endline "traversing cmt"; *)
         let iter_structure =
           Tast_iterator.(
             default_iterator.structure
               {
                 default_iterator with
                 (* value_binding = handle_vb; *)
                 expr = handle_expr modname;
               })
         in
         iter_structure str
       | _ -> ())

open Ppxlib

let str ~loc s = A.pexp_constant ~loc (Pconst_string (s, loc, None))

let g_print_value loc =
  let cases =
    A.pexp_match ~loc [%expr id]
      ((!id_type_mappings
       |> List.map (fun (Id.{ file; id; _ }, typ_info) ->
              let show_arg =
                match typ_info.typ with
                | None ->
                  (* i.e. always work *)
                  [%expr Marshal.from_string _content 0]
                | Some typ ->
                  [%expr (Marshal.from_string _content 0 : [%t typ])]
              in
              A.case
                ~lhs:
                  [%pat?
                    Ppx_debug_runtime.Id.
                      {
                        file = [%p A.pstring ~loc file];
                        id = [%p A.pint ~loc id];
                        _;
                      }]
                ~guard:None
                ~rhs:
                  [%expr
                    Format.asprintf "%a" [%e typ_info.pp_fn] [%e show_arg],
                      [%e
                        str ~loc
                          (Format.asprintf "%a" Pprintast.expression show_arg)]])
       )
      @ [
          A.case
            ~lhs:
              (* (A.ppat_tuple ~loc [[%pat? file]; A.ppat_any ~loc; [%pat? id]]) *)
              [%pat? Ppx_debug_runtime.Id.{ file; id; _ }]
            ~guard:None
            ~rhs:[%expr failwith (Format.sprintf "unknown type %s %d" file id)];
        ])
  in
  (* unsure why we have to prefix file with an underscore, or the compiler thinks it's unused *)
  let read =
    [%expr fun id (Ppx_debug_runtime.Trace.Bytestr _content) -> [%e cases]]
  in
  (* !id_type_mappings |> List.map (); *)
  [%stri let print_value = [%e read]]
(* failwith "" *)

(* Scanf.bscanf file "%s@\n%s@\n" (fun id content ->
    Format.printf "%s %s@." id
      (show_b (Marshal.from_string content 0 : b))) *)

let g_load_value loc =
  let mapping_fn =
    let cases =
      !id_type_mappings
      |> List.uniq
           ~eq:(fun
                 (Ppx_debug_runtime.Id.{ id = id1; _ }, _)
                 ({ id = id2; _ }, _)
               -> id1 = id2)
      |> List.map (fun (Id.{ id; _ }, _) ->
             A.case ~lhs:(A.pint ~loc id) ~guard:None
               ~rhs:
                 [%expr
                   Some
                     (Obj.magic
                        [%e
                          A.pexp_ident ~loc
                            { loc; txt = Lident (Format.asprintf "v%d" id) }])])
    in
    let cases =
      cases @ [A.case ~lhs:(A.ppat_any ~loc) ~guard:None ~rhs:[%expr None]]
    in
    A.value_binding ~loc
      ~pat:[%pat? mapping]
      ~expr:[%expr fun e -> [%e A.pexp_match ~loc [%expr e] cases]]
  in
  let bindings =
    (* want one variable per time point, not id *)
    !id_type_mappings
    |> List.uniq
         ~eq:(fun (Ppx_debug_runtime.Id.{ id = id1; _ }, _) ({ id = id2; _ }, _)
             -> id1 = id2)
    |> List.map (fun (Id.{ id; _ }, typ_info) ->
           (* let show_arg =
                match typ_info.typ with
                | None -> [%expr Marshal.from_string _content 0]
                | Some typ -> [%expr (Marshal.from_string _content 0 : [%t typ])]
              in *)
           A.value_binding ~loc
             ~pat:
               (A.ppat_constraint ~loc
                  (A.ppat_var ~loc { txt = Format.asprintf "v%d" id; loc })
                  (A.ptyp_constr ~loc
                     { loc; txt = Lident "ref" }
                     [
                       A.ptyp_tuple ~loc
                         [
                           A.ptyp_constr ~loc { loc; txt = Lident "string" } [];
                           A.ptyp_constr ~loc
                             { loc; txt = Lident "list" }
                             [
                               typ_info.typ
                               |> Option.get_or ~default:(A.ptyp_any ~loc);
                             ];
                         ];
                     ]))
             ~expr:
               (A.pexp_apply ~loc [%expr ref] [(Nolabel, [%expr Obj.magic 0])])
           (* let show_arg =
                match typ_info.typ with
                | None -> [%expr Marshal.from_string _content 0]
                | Some typ ->
                  [%expr (Marshal.from_string _content 0 : [%t typ])]
              in
              A.case
                ~lhs:
                  [%pat?
                    Ppx_debug_runtime.Id.
                      {
                        file = [%p A.pstring ~loc file];
                        id = [%p A.pint ~loc id];
                        _;
                      }]
                ~guard:None
                ~rhs:
                  [%expr
                    let _content = Ppx_debug_runtime.read_n _len _file in
                    Scanf.bscanf _file "\n" ();

                    Format.asprintf "%a" [%e typ_info.pp_fn] [%e show_arg]] *))
  in
  let cases =
    A.pexp_match ~loc [%expr id]
      ((!id_type_mappings
       |> List.map (fun (Id.{ file; id; _ }, typ_info) ->
              let show_arg =
                match typ_info.typ with
                | None -> [%expr Marshal.from_string _content 0]
                | Some typ ->
                  [%expr (Marshal.from_string _content 0 : [%t typ])]
              in
              A.case
                ~lhs:
                  [%pat?
                    Ppx_debug_runtime.Id.
                      {
                        file = [%p A.pstring ~loc file];
                        id = [%p A.pint ~loc id];
                        _;
                      }]
                ~guard:None
                ~rhs:
                  [%expr
                    let _content = Ppx_debug_runtime.read_n _len _file in
                    Scanf.bscanf _file "\n" ();
                    Obj.magic [%e show_arg]]))
      (* Format.asprintf "%a" [%e typ_info.pp_fn] [%e show_arg] *)
      @ [
          A.case
            ~lhs:
              (* (A.ppat_tuple ~loc [[%pat? file]; A.ppat_any ~loc; [%pat? id]]) *)
              [%pat? Ppx_debug_runtime.Id.{ file; id; _ }]
            ~guard:None
            ~rhs:[%expr failwith (Format.sprintf "unknown type %s %d" file id)];
        ])
  in
  (* unsure why we have to prefix file with an underscore, or the compiler thinks it's unused *)
  let read = [%expr fun _len _file id -> [%e cases]] in
  let run =
    [%expr
      let file = Scanf.Scanning.open_in_bin filename in
      let rec loop all =
        let typ = Scanf.bscanf file "%s@\n" (fun typ -> typ) in
        (* print_endline typ;
           print_endline (string_of_int (String.length typ)); *)
        let open Ppx_debug_runtime in
        let open Trace in
        match typ with
        | "start" ->
          let id = Id.deserialize file in
          let time = Scanf.bscanf file "%d\n" (fun t -> t) in
          let func = Scanf.bscanf file "%s@\n" (fun id -> id) in
          loop (FrameStart { id; time; func } :: all)
        | "end" ->
          let id = Id.deserialize file in
          let time = Scanf.bscanf file "%d\n" (fun t -> t) in
          let func = Scanf.bscanf file "%s@\n" (fun id -> id) in
          loop (FrameEnd { id; time; func } :: all)
        | "arg" | "value" | "match" ->
          let id = Id.deserialize file in
          let what = Scanf.bscanf file "%s@\n" (fun what -> what) in
          let time = Scanf.bscanf file "%d\n" (fun t -> t) in
          let len = Scanf.bscanf file "%d" (fun t -> t) in
          let v = load_value len file id in
          let next =
            match typ with
            | "arg" -> Argument { time; id; name = what; content = v }
            | "value" -> Value { time; id; name = what; content = v }
            | "match" -> Match { time; id; name = what; content = v }
            | _ -> failwith "invalid"
          in
          loop (next :: all)
        | "" -> List.rev all
        | _ -> failwith ("invalid " ^ typ)
      in
      (* i and id don't match. read trace, convert into tree, traverse tree and generate bindings
         doesn't work here as number of bindings is dynamic...
            (with types using i to lookup), traverse tree to set bindings, then put bindings in the repl *)
      let res = loop [] in
      Scanf.Scanning.close_in file;
      let tree = Ppx_debug_runtime.Trace.to_call_tree res in
      let rec traverse f tree =
        match tree with
        | Ppx_debug_runtime.Trace.Call { i; calls; args; _ } ->
          f tree i args;
          List.iter (traverse f) calls
        | Event { i; content; _ } -> f tree i [("val", content)]
      in
      traverse
        (fun _t i c -> match mapping i with None -> () | Some r -> r := c)
        tree;
      let x = 1 in
      let find p =
        traverse
          (fun t i _c ->
            if p = i then print_endline (Ppx_debug_runtime.Trace.show_call t)
            else ())
          tree
      in
      (* Ppx_interact_runtime.interact ~print_value () *)
      Ppx_debug_interact.(
        interact ~unit:__MODULE__ ~loc:__POS__
          ~values:
            [
              V ("x", x);
              V ("res", res);
              V ("tree", tree);
              V ("find", find)
              (* V ("v0", !v0); *)
              (* V ("v62", !v62); *);
            ]
          ())]
  in

  (* let read filename = *)

  (* !id_type_mappings |> List.map (); *)

  (* [%stri let load_value = [%e read]] *)
  A.pstr_value ~loc (* Nonrecursive *)
    Recursive
    ([A.value_binding ~loc ~pat:[%pat? load_value] ~expr:read]
    @ bindings
    @ [
        mapping_fn;
        A.value_binding ~loc
          ~pat:[%pat? read1]
          ~expr:[%expr fun filename -> [%e run]];
      ])
(* failwith "" *)

(* Scanf.bscanf file "%s@\n%s@\n" (fun id content ->
    Format.printf "%s %s@." id
      (show_b (Marshal.from_string content 0 : b))) *)

let handle_si ~loc ~path:_ payload =
  (* TODO use payload for name of identifier *)
  (* TODO go up until git, since this will reside in dune build dir *)
  (* let config = Util.read_config () in
     if config.debug then
       (traverse ())#structure_item str
     else
       str *)
  (* str *)
  (* [ *)
  walk_build_dir ();
  match payload with
  | PStr
      [
        {
          pstr_desc =
            Pstr_eval
              ( (* { pexp_desc = Pexp_constant (Pconst_string (s, _loc, _p)); _ } *)
                { pexp_desc = Pexp_ident { txt = Lident s; _ }; _ },
                _attrs );
          _;
        };
      ] ->
    begin
      match s with
      | "print_value" -> g_print_value loc
      | "load_value" -> g_load_value loc
      | _ -> failwith ("no such generator: " ^ s)
    end
  | _ -> failwith "invalid payload"
